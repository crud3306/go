

哈希表 map
===============

Go 语言中的另一个集合元素 — 哈希，也就是 Map 的实现原理；哈希表是除了数组之外，最常见的数据结构，几乎所有的语言都会有数组和哈希表这两种集合元素，有的语言将数组实现成列表，有的语言将哈希表称作结构体或者字典，但是它们是两种设计集合元素的思路，数组用于表示元素的序列，而哈希表示的是键值对之间映射关系，只是不同语言的叫法和实现稍微有些不同。

哈希表1是一种古老的数据结构，在 1953 年就有人使用拉链法实现了哈希表，它能够根据键（Key）直接访问内存中的存储位置，也就是说我们能够直接通过键找到该键对应的一个值。

设计原理
------------
哈希表是计算机科学中的最重要数据结构之一，这不仅因为它O(1)的读写性能非常优秀，还因为它提供了键值之间的映射。想要实现一个性能优异的哈希表，需要注意两个关键点 —— 哈希函数和冲突解决方法。


哈希函数
------------
实现哈希表的关键点在于如何选择哈希函数，哈希函数的选择在很大程度上能够决定哈希表的读写性能，在理想情况下，哈希函数应该能够将不同键映射到不同的索引上，这要求哈希函数输出范围大于输入范围，但是由于键的数量会远远大于映射的范围，所以在实际使用时，这个理想的结果是不可能实现的。


比较实际的方式是让哈希函数的结果能够尽可能的均匀分布，然后通过工程上的手段解决哈希碰撞的问题，但是哈希的结果一定要尽可能均匀，结果不均匀的哈希函数会造成更多的冲突并导致更差的读写性能。


在一个使用结果较为均匀的哈希函数中，哈希的增删改查都需要 O(1) 的时间复杂度，但是非常不均匀的哈希函数会导致所有的操作都会占用最差 O(n) 的复杂度，所以在哈希表中使用好的哈希函数是至关重要的。



冲突解决
------------
就像我们之前所提到的，在通常情况下，哈希函数输入的范围一定会远远大于输出的范围，所以在使用哈希表时一定会遇到冲突，哪怕我们使用了完美的哈希函数，当输入的键足够多最终也会造成冲突。

然而我们的哈希函数往往都是不完美的，输出的范围是有限的，所以一定会发生哈希碰撞，这时就需要一些方法来解决哈希碰撞的问题，常见方法的就是开放寻址法和拉链法。

- 开放寻址法
开放寻址法2是一种在哈希表中解决哈希碰撞的方法，这种方法的核心思想是对数组中的元素依次探测和比较以判断目标键值对是否存在于哈希表中，如果我们使用开放寻址法来实现哈希表，那么在支撑哈希表的数据结构就是数组，不过因为数组的长度有限，存储 (author, draven) 这个键值对时会从如下的索引开始遍历：

index := hash("author") % array.len
当我们向当前哈希表写入新的数据时发生了冲突，就会将键值对写入到下一个索引不为空的位置

开放寻址法中对性能影响最大的就是装载因子，它是数组中元素的数量与数组大小的比值，随着装载因子的增加，线性探测的平均用时就会逐渐增加，这会同时影响哈希表的读写性能，当装载率超过 70% 之后，哈希表的性能就会急剧下降，而一旦装载率达到 100%，整个哈希表就会完全失效，这时查找和插入任意元素的时间复杂度都是 O(n) 的，它们可能需要遍历数组中全部的元素，所以在实现哈希表时一定要时刻关注装载因子的变化。


- 拉链法
与开放地址法相比，拉链法是哈希表中最常见的实现方法，大多数的编程语言都用拉链法实现哈希表，它的实现比较开放地址法稍微复杂一些，但是平均查找的长度也比较短，各个用于存储节点的内存都是动态申请的，可以节省比较多的存储空间。

实现拉链法一般会使用数组加上链表，不过有一些语言会在拉链法的哈希中引入红黑树以优化性能，拉链法会使用链表数组作为哈希底层的数据结构，我们可以将它看成一个可以扩展的『二维数组』

与开放地址法一样，拉链法的装载因子越大，哈希的读写性能就越差，在一般情况下使用拉链法的哈希表装载因子都不会超过 1，当哈希表的装载因子较大时就会触发哈希的扩容，创建更多的桶来存储哈希中的元素，保证性能不会出现严重的下降。如果有 1000 个桶的哈希表存储了 10000 个键值对，它的性能是保存 1000 个键值对的 1/10，但是仍然比在链表中直接读写好 1000 倍。



数据结构
=============
Go 语言运行时同时使用了多个数据结构组合表示哈希表，其中使用 hmap 结构体来表示哈希，我们先来看一下这个结构体内部的字段：
```golang
type hmap struct {
	count     int
	flags     uint8
	B         uint8
	noverflow uint16
	hash0     uint32

	buckets    unsafe.Pointer
	oldbuckets unsafe.Pointer
	nevacuate  uintptr

	extra *mapextra
}

type mapextra struct {
	overflow    *[]*bmap
	oldoverflow *[]*bmap
	nextOverflow *bmap
}
```
- count 表示当前哈希表中的元素数量；
- B 表示当前哈希表持有的 buckets 数量，但是因为哈希表中桶的数量都 2 的倍数，所以该字段会存储对数，也就是 len(buckets) == 2^B；
- hash0 是哈希的种子，它能为哈希函数的结果引入随机性，这个值在创建哈希表时确定，并在调用哈希函数时作为参数传入；
- oldbuckets 是哈希在扩容时用于保存之前 buckets 的字段，它的大小是当前 buckets 的一半；



声明
-------------
```golang
var m1 map[string]int
var m1 map[string]string
var m2 map[string]interface{}
```


初始化
-------------
```golang
map1 := make(map[string]int) // mapping from strings to ints
map1["x1"] = 37
map1["x2"] = 38

//或者如下方式，二者是等价的
map1 := map[string]int{
    "x1":   31,
    "x2": 34,
}

fmt.Println(map1, map1["x2"])

for i, v := range map1 {
	fmt.Println(i, v)
}
```


注意：map一定要初始化后，才能通过键值来赋值。比如下方的仅声名，就赋值会报错
```golang
var m1 map[string]string
m1["a1"] = "111"
fmt.Println(m1)
// 这会报错：
// Trace: assignment to entry in nil map

// 我们可以打印map看一下
fmt.Println(m1)
fmt.Println(m1 == nil)
// 通过打印发现，仅声明的map是nil
```


获取元素
```golang
// 直接取
fmt.Println(map1["x1"])

// 取的同时验证是否存在该key
if v, exist := map1["x1"]; exist {
	map1[v]
}

// 遍历，但注意：map是无序的
for i, v := range map1 {
	fmt.Println(i, v)
}
```


删除元素
```golang
delete(map1, "x1")
```

map元素个数
```golang
fmt.Println(len(map1))
```



示例：
------------------
```golang
package main

import (
    "fmt"
    "unsafe"
)

func main() {
    // 声明后赋值
    var m map[int]string
    fmt.Println(m) // 输出空的map：map[]
    //m[1] = `aa`    // 向未初始化的map中赋值报错：panic: assignment to entry in nil map

    // 声明并初始化，初始化使用{} 或 make 函数（创建类型并分配空间）
    var m1 = map[string]int{}
    var m2 = make(map[string]int)
    m1[`a`] = 11
    m2[`b`] = 22
    fmt.Println(m1) // 输出：map[a:11]
    fmt.Println(m2) // 输出：map[b:22]

    // 初始化多个值
    var m3 = map[string]string{"a": "aaa", "b": "bbb"}
    m3["c"] = "ccc"
    fmt.Println(m3) // 输出：map[a:aaa b:bbb c:ccc]

    // 删除 map 中的值
    delete(m3, "a") // 删除键 a 对应的值
    fmt.Println(m3) // 输出：map[b:bbb c:ccc]

    // 查找 map 中的元素
    v, ok := m3["b"]
    if ok {
        fmt.Println(ok)
        fmt.Println("m3中b的值为：", v) // 输出：m3中b的值为： bbb
    }
    // 或者
    if v, ok := m3["b"]; ok { // 流程处理后面讲
        fmt.Println("m3中b的值为：", v) // 输出：m3中b的值为： bbb
    }

    fmt.Println(m3["c"]) // 直接取值，输出：ccc

    // map 中的值可以是任意类型
    m4 := make(map[string][5]int)
    m4["a"] = [5]int{1, 2, 3, 4, 5}
    m4["b"] = [5]int{11, 22, 33}
    fmt.Println(m4)                // 输出：map[a:[1 2 3 4 5] b:[11 22 33 0 0]]
    fmt.Println(unsafe.Sizeof(m4)) // 输出：8，为8个字节，map其实是个指针，指向某个内存空间
}
```